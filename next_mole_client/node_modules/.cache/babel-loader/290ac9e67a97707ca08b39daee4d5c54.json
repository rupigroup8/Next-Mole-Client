{"ast":null,"code":"var _require = require('three-pathfinding'),\n    Pathfinding = _require.Pathfinding;\n\nvar pathfinder = new Pathfinding();\nvar ZONE = 'level';\n/**\n * nav\n *\n * Pathfinding system, using PatrolJS.\n */\n\nmodule.exports = AFRAME.registerSystem('nav', {\n  init: function init() {\n    this.navMesh = null;\n    this.agents = new Set();\n  },\n\n  /**\n   * @param {THREE.Geometry} geometry\n   */\n  setNavMeshGeometry: function setNavMeshGeometry(geometry) {\n    this.navMesh = new THREE.Mesh(geometry);\n    pathfinder.setZoneData(ZONE, Pathfinding.createZone(geometry));\n    Array.from(this.agents).forEach(function (agent) {\n      return agent.updateNavLocation();\n    });\n  },\n\n  /**\n   * @return {THREE.Mesh}\n   */\n  getNavMesh: function getNavMesh() {\n    return this.navMesh;\n  },\n\n  /**\n   * @param {NavAgent} ctrl\n   */\n  addAgent: function addAgent(ctrl) {\n    this.agents.add(ctrl);\n  },\n\n  /**\n   * @param {NavAgent} ctrl\n   */\n  removeAgent: function removeAgent(ctrl) {\n    this.agents.delete(ctrl);\n  },\n\n  /**\n   * @param  {THREE.Vector3} start\n   * @param  {THREE.Vector3} end\n   * @param  {number} groupID\n   * @return {Array<THREE.Vector3>}\n   */\n  getPath: function getPath(start, end, groupID) {\n    return this.navMesh ? pathfinder.findPath(start, end, ZONE, groupID) : null;\n  },\n\n  /**\n   * @param {THREE.Vector3} position\n   * @return {number}\n   */\n  getGroup: function getGroup(position) {\n    return this.navMesh ? pathfinder.getGroup(ZONE, position) : null;\n  },\n\n  /**\n   * @param  {THREE.Vector3} position\n   * @param  {number} groupID\n   * @return {Node}\n   */\n  getNode: function getNode(position, groupID) {\n    return this.navMesh ? pathfinder.getClosestNode(position, ZONE, groupID, true) : null;\n  },\n\n  /**\n   * @param  {THREE.Vector3} start Starting position.\n   * @param  {THREE.Vector3} end Desired ending position.\n   * @param  {number} groupID\n   * @param  {Node} node\n   * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.\n   * @return {Node} Current node, after step is taken.\n   */\n  clampStep: function clampStep(start, end, groupID, node, endTarget) {\n    if (!this.navMesh) {\n      endTarget.copy(end);\n      return null;\n    } else if (!node) {\n      endTarget.copy(end);\n      return this.getNode(end, groupID);\n    }\n\n    return pathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);\n  }\n});","map":{"version":3,"sources":["/Users/rgoren/Desktop/nextMoleAppClient/next_mole_client/node_modules/aframe-extras/src/pathfinding/system.js"],"names":["require","Pathfinding","pathfinder","ZONE","module","exports","AFRAME","registerSystem","init","navMesh","agents","Set","setNavMeshGeometry","geometry","THREE","Mesh","setZoneData","createZone","Array","from","forEach","agent","updateNavLocation","getNavMesh","addAgent","ctrl","add","removeAgent","delete","getPath","start","end","groupID","findPath","getGroup","position","getNode","getClosestNode","clampStep","node","endTarget","copy"],"mappings":"eAAwBA,OAAO,CAAC,mBAAD,C;IAAvBC,W,YAAAA,W;;AAER,IAAMC,UAAU,GAAG,IAAID,WAAJ,EAAnB;AACA,IAAME,IAAI,GAAG,OAAb;AAEA;;;;;;AAKAC,MAAM,CAACC,OAAP,GAAiBC,MAAM,CAACC,cAAP,CAAsB,KAAtB,EAA6B;AAC5CC,EAAAA,IAAI,EAAE,gBAAY;AAChB,SAAKC,OAAL,GAAe,IAAf;AACA,SAAKC,MAAL,GAAc,IAAIC,GAAJ,EAAd;AACD,GAJ2C;;AAM5C;;;AAGAC,EAAAA,kBAAkB,EAAE,4BAAUC,QAAV,EAAoB;AACtC,SAAKJ,OAAL,GAAe,IAAIK,KAAK,CAACC,IAAV,CAAeF,QAAf,CAAf;AACAX,IAAAA,UAAU,CAACc,WAAX,CAAuBb,IAAvB,EAA6BF,WAAW,CAACgB,UAAZ,CAAuBJ,QAAvB,CAA7B;AACAK,IAAAA,KAAK,CAACC,IAAN,CAAW,KAAKT,MAAhB,EAAwBU,OAAxB,CAAgC,UAACC,KAAD;AAAA,aAAWA,KAAK,CAACC,iBAAN,EAAX;AAAA,KAAhC;AACD,GAb2C;;AAe5C;;;AAGAC,EAAAA,UAAU,EAAE,sBAAY;AACtB,WAAO,KAAKd,OAAZ;AACD,GApB2C;;AAsB5C;;;AAGAe,EAAAA,QAAQ,EAAE,kBAAUC,IAAV,EAAgB;AACxB,SAAKf,MAAL,CAAYgB,GAAZ,CAAgBD,IAAhB;AACD,GA3B2C;;AA6B5C;;;AAGAE,EAAAA,WAAW,EAAE,qBAAUF,IAAV,EAAgB;AAC3B,SAAKf,MAAL,CAAYkB,MAAZ,CAAmBH,IAAnB;AACD,GAlC2C;;AAoC5C;;;;;;AAMAI,EAAAA,OAAO,EAAE,iBAAUC,KAAV,EAAiBC,GAAjB,EAAsBC,OAAtB,EAA+B;AACtC,WAAO,KAAKvB,OAAL,GACHP,UAAU,CAAC+B,QAAX,CAAoBH,KAApB,EAA2BC,GAA3B,EAAgC5B,IAAhC,EAAsC6B,OAAtC,CADG,GAEH,IAFJ;AAGD,GA9C2C;;AAgD5C;;;;AAIAE,EAAAA,QAAQ,EAAE,kBAAUC,QAAV,EAAoB;AAC5B,WAAO,KAAK1B,OAAL,GACHP,UAAU,CAACgC,QAAX,CAAoB/B,IAApB,EAA0BgC,QAA1B,CADG,GAEH,IAFJ;AAGD,GAxD2C;;AA0D5C;;;;;AAKAC,EAAAA,OAAO,EAAE,iBAAUD,QAAV,EAAoBH,OAApB,EAA6B;AACpC,WAAO,KAAKvB,OAAL,GACHP,UAAU,CAACmC,cAAX,CAA0BF,QAA1B,EAAoChC,IAApC,EAA0C6B,OAA1C,EAAmD,IAAnD,CADG,GAEH,IAFJ;AAGD,GAnE2C;;AAqE5C;;;;;;;;AAQAM,EAAAA,SAAS,EAAE,mBAAUR,KAAV,EAAiBC,GAAjB,EAAsBC,OAAtB,EAA+BO,IAA/B,EAAqCC,SAArC,EAAgD;AACzD,QAAI,CAAC,KAAK/B,OAAV,EAAmB;AACjB+B,MAAAA,SAAS,CAACC,IAAV,CAAeV,GAAf;AACA,aAAO,IAAP;AACD,KAHD,MAGO,IAAI,CAACQ,IAAL,EAAW;AAChBC,MAAAA,SAAS,CAACC,IAAV,CAAeV,GAAf;AACA,aAAO,KAAKK,OAAL,CAAaL,GAAb,EAAkBC,OAAlB,CAAP;AACD;;AACD,WAAO9B,UAAU,CAACoC,SAAX,CAAqBR,KAArB,EAA4BC,GAA5B,EAAiCQ,IAAjC,EAAuCpC,IAAvC,EAA6C6B,OAA7C,EAAsDQ,SAAtD,CAAP;AACD;AAtF2C,CAA7B,CAAjB","sourcesContent":["const { Pathfinding } = require('three-pathfinding');\n\nconst pathfinder = new Pathfinding();\nconst ZONE = 'level';\n\n/**\n * nav\n *\n * Pathfinding system, using PatrolJS.\n */\nmodule.exports = AFRAME.registerSystem('nav', {\n  init: function () {\n    this.navMesh = null;\n    this.agents = new Set();\n  },\n\n  /**\n   * @param {THREE.Geometry} geometry\n   */\n  setNavMeshGeometry: function (geometry) {\n    this.navMesh = new THREE.Mesh(geometry);\n    pathfinder.setZoneData(ZONE, Pathfinding.createZone(geometry));\n    Array.from(this.agents).forEach((agent) => agent.updateNavLocation());\n  },\n\n  /**\n   * @return {THREE.Mesh}\n   */\n  getNavMesh: function () {\n    return this.navMesh;\n  },\n\n  /**\n   * @param {NavAgent} ctrl\n   */\n  addAgent: function (ctrl) {\n    this.agents.add(ctrl);\n  },\n\n  /**\n   * @param {NavAgent} ctrl\n   */\n  removeAgent: function (ctrl) {\n    this.agents.delete(ctrl);\n  },\n\n  /**\n   * @param  {THREE.Vector3} start\n   * @param  {THREE.Vector3} end\n   * @param  {number} groupID\n   * @return {Array<THREE.Vector3>}\n   */\n  getPath: function (start, end, groupID) {\n    return this.navMesh\n      ? pathfinder.findPath(start, end, ZONE, groupID)\n      : null;\n  },\n\n  /**\n   * @param {THREE.Vector3} position\n   * @return {number}\n   */\n  getGroup: function (position) {\n    return this.navMesh\n      ? pathfinder.getGroup(ZONE, position)\n      : null;\n  },\n\n  /**\n   * @param  {THREE.Vector3} position\n   * @param  {number} groupID\n   * @return {Node}\n   */\n  getNode: function (position, groupID) {\n    return this.navMesh\n      ? pathfinder.getClosestNode(position, ZONE, groupID, true)\n      : null;\n  },\n\n  /**\n   * @param  {THREE.Vector3} start Starting position.\n   * @param  {THREE.Vector3} end Desired ending position.\n   * @param  {number} groupID\n   * @param  {Node} node\n   * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.\n   * @return {Node} Current node, after step is taken.\n   */\n  clampStep: function (start, end, groupID, node, endTarget) {\n    if (!this.navMesh) {\n      endTarget.copy(end);\n      return null;\n    } else if (!node) {\n      endTarget.copy(end);\n      return this.getNode(end, groupID);\n    }\n    return pathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);\n  }\n});\n"]},"metadata":{},"sourceType":"script"}