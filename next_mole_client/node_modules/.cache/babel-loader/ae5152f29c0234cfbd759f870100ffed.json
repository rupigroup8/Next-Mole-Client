{"ast":null,"code":"/**\n * This is Barnes Hut simulation algorithm for 2d case. Implementation\n * is highly optimized (avoids recusion and gc pressure)\n *\n * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html\n */\nmodule.exports = function (options) {\n  options = options || {};\n  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n  options.theta = typeof options.theta === 'number' ? options.theta : 0.8; // we require deterministic randomness here\n\n  var random = require('ngraph.random').random(1984),\n      Node = require('./node'),\n      InsertStack = require('./insertStack'),\n      isSamePosition = require('./isSamePosition');\n\n  var gravity = options.gravity,\n      updateQueue = [],\n      insertStack = new InsertStack(),\n      theta = options.theta,\n      nodesCache = [],\n      currentInCache = 0,\n      root = newNode();\n  return {\n    insertBodies: insertBodies,\n\n    /**\n     * Gets root node if its present\n     */\n    getRoot: function getRoot() {\n      return root;\n    },\n    updateBodyForce: update,\n    options: function options(newOptions) {\n      if (newOptions) {\n        if (typeof newOptions.gravity === 'number') {\n          gravity = newOptions.gravity;\n        }\n\n        if (typeof newOptions.theta === 'number') {\n          theta = newOptions.theta;\n        }\n\n        return this;\n      }\n\n      return {\n        gravity: gravity,\n        theta: theta\n      };\n    }\n  };\n\n  function newNode() {\n    // To avoid pressure on GC we reuse nodes.\n    var node = nodesCache[currentInCache];\n\n    if (node) {\n      node.quad0 = null;\n      node.quad1 = null;\n      node.quad2 = null;\n      node.quad3 = null;\n      node.body = null;\n      node.mass = node.massX = node.massY = 0;\n      node.left = node.right = node.top = node.bottom = 0;\n    } else {\n      node = new Node();\n      nodesCache[currentInCache] = node;\n    }\n\n    ++currentInCache;\n    return node;\n  }\n\n  function update(sourceBody) {\n    var queue = updateQueue,\n        v,\n        dx,\n        dy,\n        r,\n        fx = 0,\n        fy = 0,\n        queueLength = 1,\n        shiftIdx = 0,\n        pushIdx = 1;\n    queue[0] = root;\n\n    while (queueLength) {\n      var node = queue[shiftIdx],\n          body = node.body;\n      queueLength -= 1;\n      shiftIdx += 1;\n      var differentBody = body !== sourceBody;\n\n      if (body && differentBody) {\n        // If the current node is a leaf node (and it is not source body),\n        // calculate the force exerted by the current node on body, and add this\n        // amount to body's net force.\n        dx = body.pos.x - sourceBody.pos.x;\n        dy = body.pos.y - sourceBody.pos.y;\n        r = Math.sqrt(dx * dx + dy * dy);\n\n        if (r === 0) {\n          // Poor man's protection against zero distance.\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n        } // This is standard gravition force calculation but we divide\n        // by r^3 to save two operations when normalizing force vector.\n\n\n        v = gravity * body.mass * sourceBody.mass / (r * r * r);\n        fx += v * dx;\n        fy += v * dy;\n      } else if (differentBody) {\n        // Otherwise, calculate the ratio s / r,  where s is the width of the region\n        // represented by the internal node, and r is the distance between the body\n        // and the node's center-of-mass\n        dx = node.massX / node.mass - sourceBody.pos.x;\n        dy = node.massY / node.mass - sourceBody.pos.y;\n        r = Math.sqrt(dx * dx + dy * dy);\n\n        if (r === 0) {\n          // Sorry about code duplucation. I don't want to create many functions\n          // right away. Just want to see performance first.\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n        } // If s / r < θ, treat this internal node as a single body, and calculate the\n        // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n\n\n        if ((node.right - node.left) / r < theta) {\n          // in the if statement above we consider node's width only\n          // because the region was squarified during tree creation.\n          // Thus there is no difference between using width or height.\n          v = gravity * node.mass * sourceBody.mass / (r * r * r);\n          fx += v * dx;\n          fy += v * dy;\n        } else {\n          // Otherwise, run the procedure recursively on each of the current node's children.\n          // I intentionally unfolded this loop, to save several CPU cycles.\n          if (node.quad0) {\n            queue[pushIdx] = node.quad0;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n\n          if (node.quad1) {\n            queue[pushIdx] = node.quad1;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n\n          if (node.quad2) {\n            queue[pushIdx] = node.quad2;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n\n          if (node.quad3) {\n            queue[pushIdx] = node.quad3;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n        }\n      }\n    }\n\n    sourceBody.force.x += fx;\n    sourceBody.force.y += fy;\n  }\n\n  function insertBodies(bodies) {\n    var x1 = Number.MAX_VALUE,\n        y1 = Number.MAX_VALUE,\n        x2 = Number.MIN_VALUE,\n        y2 = Number.MIN_VALUE,\n        i,\n        max = bodies.length; // To reduce quad tree depth we are looking for exact bounding box of all particles.\n\n    i = max;\n\n    while (i--) {\n      var x = bodies[i].pos.x;\n      var y = bodies[i].pos.y;\n\n      if (x < x1) {\n        x1 = x;\n      }\n\n      if (x > x2) {\n        x2 = x;\n      }\n\n      if (y < y1) {\n        y1 = y;\n      }\n\n      if (y > y2) {\n        y2 = y;\n      }\n    } // Squarify the bounds.\n\n\n    var dx = x2 - x1,\n        dy = y2 - y1;\n\n    if (dx > dy) {\n      y2 = y1 + dx;\n    } else {\n      x2 = x1 + dy;\n    }\n\n    currentInCache = 0;\n    root = newNode();\n    root.left = x1;\n    root.right = x2;\n    root.top = y1;\n    root.bottom = y2;\n    i = max - 1;\n\n    if (i >= 0) {\n      root.body = bodies[i];\n    }\n\n    while (i--) {\n      insert(bodies[i], root);\n    }\n  }\n\n  function insert(newBody) {\n    insertStack.reset();\n    insertStack.push(root, newBody);\n\n    while (!insertStack.isEmpty()) {\n      var stackItem = insertStack.pop(),\n          node = stackItem.node,\n          body = stackItem.body;\n\n      if (!node.body) {\n        // This is internal node. Update the total mass of the node and center-of-mass.\n        var x = body.pos.x;\n        var y = body.pos.y;\n        node.mass = node.mass + body.mass;\n        node.massX = node.massX + body.mass * x;\n        node.massY = node.massY + body.mass * y; // Recursively insert the body in the appropriate quadrant.\n        // But first find the appropriate quadrant.\n\n        var quadIdx = 0,\n            // Assume we are in the 0's quad.\n        left = node.left,\n            right = (node.right + left) / 2,\n            top = node.top,\n            bottom = (node.bottom + top) / 2;\n\n        if (x > right) {\n          // somewhere in the eastern part.\n          quadIdx = quadIdx + 1;\n          left = right;\n          right = node.right;\n        }\n\n        if (y > bottom) {\n          // and in south.\n          quadIdx = quadIdx + 2;\n          top = bottom;\n          bottom = node.bottom;\n        }\n\n        var child = getChild(node, quadIdx);\n\n        if (!child) {\n          // The node is internal but this quadrant is not taken. Add\n          // subnode to it.\n          child = newNode();\n          child.left = left;\n          child.top = top;\n          child.right = right;\n          child.bottom = bottom;\n          child.body = body;\n          setChild(node, quadIdx, child);\n        } else {\n          // continue searching in this quadrant.\n          insertStack.push(child, body);\n        }\n      } else {\n        // We are trying to add to the leaf node.\n        // We have to convert current leaf into internal node\n        // and continue adding two nodes.\n        var oldBody = node.body;\n        node.body = null; // internal nodes do not cary bodies\n\n        if (isSamePosition(oldBody.pos, body.pos)) {\n          // Prevent infinite subdivision by bumping one node\n          // anywhere in this quadrant\n          var retriesCount = 3;\n\n          do {\n            var offset = random.nextDouble();\n            var dx = (node.right - node.left) * offset;\n            var dy = (node.bottom - node.top) * offset;\n            oldBody.pos.x = node.left + dx;\n            oldBody.pos.y = node.top + dy;\n            retriesCount -= 1; // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n            // This is very bad, we ran out of precision.\n            // if we do not return from the method we'll get into\n            // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n            // Next layout iteration should get larger bounding box in the first step and fix this\n            return;\n          }\n        } // Next iteration should subdivide node further.\n\n\n        insertStack.push(node, oldBody);\n        insertStack.push(node, body);\n      }\n    }\n  }\n};\n\nfunction getChild(node, idx) {\n  if (idx === 0) return node.quad0;\n  if (idx === 1) return node.quad1;\n  if (idx === 2) return node.quad2;\n  if (idx === 3) return node.quad3;\n  return null;\n}\n\nfunction setChild(node, idx, child) {\n  if (idx === 0) node.quad0 = child;else if (idx === 1) node.quad1 = child;else if (idx === 2) node.quad2 = child;else if (idx === 3) node.quad3 = child;\n}","map":{"version":3,"sources":["/Users/rgoren/Desktop/nextMoleAppClient/next_mole_client/node_modules/ngraph.quadtreebh/index.js"],"names":["module","exports","options","gravity","theta","random","require","Node","InsertStack","isSamePosition","updateQueue","insertStack","nodesCache","currentInCache","root","newNode","insertBodies","getRoot","updateBodyForce","update","newOptions","node","quad0","quad1","quad2","quad3","body","mass","massX","massY","left","right","top","bottom","sourceBody","queue","v","dx","dy","r","fx","fy","queueLength","shiftIdx","pushIdx","differentBody","pos","x","y","Math","sqrt","nextDouble","force","bodies","x1","Number","MAX_VALUE","y1","x2","MIN_VALUE","y2","i","max","length","insert","newBody","reset","push","isEmpty","stackItem","pop","quadIdx","child","getChild","setChild","oldBody","retriesCount","offset","idx"],"mappings":"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","sourcesContent":["/**\n * This is Barnes Hut simulation algorithm for 2d case. Implementation\n * is highly optimized (avoids recusion and gc pressure)\n *\n * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html\n */\n\nmodule.exports = function(options) {\n  options = options || {};\n  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;\n\n  // we require deterministic randomness here\n  var random = require('ngraph.random').random(1984),\n    Node = require('./node'),\n    InsertStack = require('./insertStack'),\n    isSamePosition = require('./isSamePosition');\n\n  var gravity = options.gravity,\n    updateQueue = [],\n    insertStack = new InsertStack(),\n    theta = options.theta,\n\n    nodesCache = [],\n    currentInCache = 0,\n    root = newNode();\n\n  return {\n    insertBodies: insertBodies,\n    /**\n     * Gets root node if its present\n     */\n    getRoot: function() {\n      return root;\n    },\n    updateBodyForce: update,\n    options: function(newOptions) {\n      if (newOptions) {\n        if (typeof newOptions.gravity === 'number') {\n          gravity = newOptions.gravity;\n        }\n        if (typeof newOptions.theta === 'number') {\n          theta = newOptions.theta;\n        }\n\n        return this;\n      }\n\n      return {\n        gravity: gravity,\n        theta: theta\n      };\n    }\n  };\n\n  function newNode() {\n    // To avoid pressure on GC we reuse nodes.\n    var node = nodesCache[currentInCache];\n    if (node) {\n      node.quad0 = null;\n      node.quad1 = null;\n      node.quad2 = null;\n      node.quad3 = null;\n      node.body = null;\n      node.mass = node.massX = node.massY = 0;\n      node.left = node.right = node.top = node.bottom = 0;\n    } else {\n      node = new Node();\n      nodesCache[currentInCache] = node;\n    }\n\n    ++currentInCache;\n    return node;\n  }\n\n  function update(sourceBody) {\n    var queue = updateQueue,\n      v,\n      dx,\n      dy,\n      r, fx = 0,\n      fy = 0,\n      queueLength = 1,\n      shiftIdx = 0,\n      pushIdx = 1;\n\n    queue[0] = root;\n\n    while (queueLength) {\n      var node = queue[shiftIdx],\n        body = node.body;\n\n      queueLength -= 1;\n      shiftIdx += 1;\n      var differentBody = (body !== sourceBody);\n      if (body && differentBody) {\n        // If the current node is a leaf node (and it is not source body),\n        // calculate the force exerted by the current node on body, and add this\n        // amount to body's net force.\n        dx = body.pos.x - sourceBody.pos.x;\n        dy = body.pos.y - sourceBody.pos.y;\n        r = Math.sqrt(dx * dx + dy * dy);\n\n        if (r === 0) {\n          // Poor man's protection against zero distance.\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n        }\n\n        // This is standard gravition force calculation but we divide\n        // by r^3 to save two operations when normalizing force vector.\n        v = gravity * body.mass * sourceBody.mass / (r * r * r);\n        fx += v * dx;\n        fy += v * dy;\n      } else if (differentBody) {\n        // Otherwise, calculate the ratio s / r,  where s is the width of the region\n        // represented by the internal node, and r is the distance between the body\n        // and the node's center-of-mass\n        dx = node.massX / node.mass - sourceBody.pos.x;\n        dy = node.massY / node.mass - sourceBody.pos.y;\n        r = Math.sqrt(dx * dx + dy * dy);\n\n        if (r === 0) {\n          // Sorry about code duplucation. I don't want to create many functions\n          // right away. Just want to see performance first.\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n        }\n        // If s / r < θ, treat this internal node as a single body, and calculate the\n        // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n        if ((node.right - node.left) / r < theta) {\n          // in the if statement above we consider node's width only\n          // because the region was squarified during tree creation.\n          // Thus there is no difference between using width or height.\n          v = gravity * node.mass * sourceBody.mass / (r * r * r);\n          fx += v * dx;\n          fy += v * dy;\n        } else {\n          // Otherwise, run the procedure recursively on each of the current node's children.\n\n          // I intentionally unfolded this loop, to save several CPU cycles.\n          if (node.quad0) {\n            queue[pushIdx] = node.quad0;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad1) {\n            queue[pushIdx] = node.quad1;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad2) {\n            queue[pushIdx] = node.quad2;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad3) {\n            queue[pushIdx] = node.quad3;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n        }\n      }\n    }\n\n    sourceBody.force.x += fx;\n    sourceBody.force.y += fy;\n  }\n\n  function insertBodies(bodies) {\n    var x1 = Number.MAX_VALUE,\n      y1 = Number.MAX_VALUE,\n      x2 = Number.MIN_VALUE,\n      y2 = Number.MIN_VALUE,\n      i,\n      max = bodies.length;\n\n    // To reduce quad tree depth we are looking for exact bounding box of all particles.\n    i = max;\n    while (i--) {\n      var x = bodies[i].pos.x;\n      var y = bodies[i].pos.y;\n      if (x < x1) {\n        x1 = x;\n      }\n      if (x > x2) {\n        x2 = x;\n      }\n      if (y < y1) {\n        y1 = y;\n      }\n      if (y > y2) {\n        y2 = y;\n      }\n    }\n\n    // Squarify the bounds.\n    var dx = x2 - x1,\n      dy = y2 - y1;\n    if (dx > dy) {\n      y2 = y1 + dx;\n    } else {\n      x2 = x1 + dy;\n    }\n\n    currentInCache = 0;\n    root = newNode();\n    root.left = x1;\n    root.right = x2;\n    root.top = y1;\n    root.bottom = y2;\n\n    i = max - 1;\n    if (i >= 0) {\n      root.body = bodies[i];\n    }\n    while (i--) {\n      insert(bodies[i], root);\n    }\n  }\n\n  function insert(newBody) {\n    insertStack.reset();\n    insertStack.push(root, newBody);\n\n    while (!insertStack.isEmpty()) {\n      var stackItem = insertStack.pop(),\n        node = stackItem.node,\n        body = stackItem.body;\n\n      if (!node.body) {\n        // This is internal node. Update the total mass of the node and center-of-mass.\n        var x = body.pos.x;\n        var y = body.pos.y;\n        node.mass = node.mass + body.mass;\n        node.massX = node.massX + body.mass * x;\n        node.massY = node.massY + body.mass * y;\n\n        // Recursively insert the body in the appropriate quadrant.\n        // But first find the appropriate quadrant.\n        var quadIdx = 0, // Assume we are in the 0's quad.\n          left = node.left,\n          right = (node.right + left) / 2,\n          top = node.top,\n          bottom = (node.bottom + top) / 2;\n\n        if (x > right) { // somewhere in the eastern part.\n          quadIdx = quadIdx + 1;\n          left = right;\n          right = node.right;\n        }\n        if (y > bottom) { // and in south.\n          quadIdx = quadIdx + 2;\n          top = bottom;\n          bottom = node.bottom;\n        }\n\n        var child = getChild(node, quadIdx);\n        if (!child) {\n          // The node is internal but this quadrant is not taken. Add\n          // subnode to it.\n          child = newNode();\n          child.left = left;\n          child.top = top;\n          child.right = right;\n          child.bottom = bottom;\n          child.body = body;\n\n          setChild(node, quadIdx, child);\n        } else {\n          // continue searching in this quadrant.\n          insertStack.push(child, body);\n        }\n      } else {\n        // We are trying to add to the leaf node.\n        // We have to convert current leaf into internal node\n        // and continue adding two nodes.\n        var oldBody = node.body;\n        node.body = null; // internal nodes do not cary bodies\n\n        if (isSamePosition(oldBody.pos, body.pos)) {\n          // Prevent infinite subdivision by bumping one node\n          // anywhere in this quadrant\n          var retriesCount = 3;\n          do {\n            var offset = random.nextDouble();\n            var dx = (node.right - node.left) * offset;\n            var dy = (node.bottom - node.top) * offset;\n\n            oldBody.pos.x = node.left + dx;\n            oldBody.pos.y = node.top + dy;\n            retriesCount -= 1;\n            // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n            // This is very bad, we ran out of precision.\n            // if we do not return from the method we'll get into\n            // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n            // Next layout iteration should get larger bounding box in the first step and fix this\n            return;\n          }\n        }\n        // Next iteration should subdivide node further.\n        insertStack.push(node, oldBody);\n        insertStack.push(node, body);\n      }\n    }\n  }\n};\n\nfunction getChild(node, idx) {\n  if (idx === 0) return node.quad0;\n  if (idx === 1) return node.quad1;\n  if (idx === 2) return node.quad2;\n  if (idx === 3) return node.quad3;\n  return null;\n}\n\nfunction setChild(node, idx, child) {\n  if (idx === 0) node.quad0 = child;\n  else if (idx === 1) node.quad1 = child;\n  else if (idx === 2) node.quad2 = child;\n  else if (idx === 3) node.quad3 = child;\n}\n"]},"metadata":{},"sourceType":"script"}