{"ast":null,"code":"/**\n * Manages a simulation of physical forces acting on bodies and springs.\n */\nmodule.exports = physicsSimulator;\n\nfunction physicsSimulator(settings) {\n  var Spring = require('./lib/spring');\n\n  var expose = require('ngraph.expose');\n\n  var merge = require('ngraph.merge');\n\n  var eventify = require('ngraph.events');\n\n  settings = merge(settings, {\n    /**\n     * Ideal length for links (springs in physical model).\n     */\n    springLength: 30,\n\n    /**\n     * Hook's law coefficient. 1 - solid spring.\n     */\n    springCoeff: 0.0008,\n\n    /**\n     * Coulomb's law coefficient. It's used to repel nodes thus should be negative\n     * if you make it positive nodes start attract each other :).\n     */\n    gravity: -1.2,\n\n    /**\n     * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).\n     * The closer it's to 1 the more nodes algorithm will have to go through.\n     * Setting it to one makes Barnes Hut simulation no different from\n     * brute-force forces calculation (each node is considered).\n     */\n    theta: 0.8,\n\n    /**\n     * Drag force coefficient. Used to slow down system, thus should be less than 1.\n     * The closer it is to 0 the less tight system will be.\n     */\n    dragCoeff: 0.02,\n\n    /**\n     * Default time step (dt) for forces integration\n     */\n    timeStep: 20\n  }); // We allow clients to override basic factory methods:\n\n  var createQuadTree = settings.createQuadTree || require('ngraph.quadtreebh');\n\n  var createBounds = settings.createBounds || require('./lib/bounds');\n\n  var createDragForce = settings.createDragForce || require('./lib/dragForce');\n\n  var createSpringForce = settings.createSpringForce || require('./lib/springForce');\n\n  var integrate = settings.integrator || require('./lib/eulerIntegrator');\n\n  var createBody = settings.createBody || require('./lib/createBody');\n\n  var bodies = [],\n      // Bodies in this simulation.\n  springs = [],\n      // Springs in this simulation.\n  quadTree = createQuadTree(settings),\n      bounds = createBounds(bodies, settings),\n      springForce = createSpringForce(settings),\n      dragForce = createDragForce(settings);\n  var bboxNeedsUpdate = true;\n  var totalMovement = 0; // how much movement we made on last step\n\n  var publicApi = {\n    /**\n     * Array of bodies, registered with current simulator\n     *\n     * Note: To add new body, use addBody() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    bodies: bodies,\n    quadTree: quadTree,\n\n    /**\n     * Array of springs, registered with current simulator\n     *\n     * Note: To add new spring, use addSpring() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    springs: springs,\n\n    /**\n     * Returns settings with which current simulator was initialized\n     */\n    settings: settings,\n\n    /**\n     * Performs one step of force simulation.\n     *\n     * @returns {boolean} true if system is considered stable; False otherwise.\n     */\n    step: function () {\n      accumulateForces();\n      var movement = integrate(bodies, settings.timeStep);\n      bounds.update();\n      return movement;\n    },\n\n    /**\n     * Adds body to the system\n     *\n     * @param {ngraph.physics.primitives.Body} body physical body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBody: function (body) {\n      if (!body) {\n        throw new Error('Body is required');\n      }\n\n      bodies.push(body);\n      return body;\n    },\n\n    /**\n     * Adds body to the system at given position\n     *\n     * @param {Object} pos position of a body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBodyAt: function (pos) {\n      if (!pos) {\n        throw new Error('Body position is required');\n      }\n\n      var body = createBody(pos);\n      bodies.push(body);\n      return body;\n    },\n\n    /**\n     * Removes body from the system\n     *\n     * @param {ngraph.physics.primitives.Body} body to remove\n     *\n     * @returns {Boolean} true if body found and removed. falsy otherwise;\n     */\n    removeBody: function (body) {\n      if (!body) {\n        return;\n      }\n\n      var idx = bodies.indexOf(body);\n\n      if (idx < 0) {\n        return;\n      }\n\n      bodies.splice(idx, 1);\n\n      if (bodies.length === 0) {\n        bounds.reset();\n      }\n\n      return true;\n    },\n\n    /**\n     * Adds a spring to this simulation.\n     *\n     * @returns {Object} - a handle for a spring. If you want to later remove\n     * spring pass it to removeSpring() method.\n     */\n    addSpring: function (body1, body2, springLength, springCoefficient) {\n      if (!body1 || !body2) {\n        throw new Error('Cannot add null spring to force simulator');\n      }\n\n      if (typeof springLength !== 'number') {\n        springLength = -1; // assume global configuration\n      }\n\n      var spring = new Spring(body1, body2, springLength, springCoefficient >= 0 ? springCoefficient : -1);\n      springs.push(spring); // TODO: could mark simulator as dirty.\n\n      return spring;\n    },\n\n    /**\n     * Returns amount of movement performed on last step() call\n     */\n    getTotalMovement: function () {\n      return totalMovement;\n    },\n\n    /**\n     * Removes spring from the system\n     *\n     * @param {Object} spring to remove. Spring is an object returned by addSpring\n     *\n     * @returns {Boolean} true if spring found and removed. falsy otherwise;\n     */\n    removeSpring: function (spring) {\n      if (!spring) {\n        return;\n      }\n\n      var idx = springs.indexOf(spring);\n\n      if (idx > -1) {\n        springs.splice(idx, 1);\n        return true;\n      }\n    },\n    getBestNewBodyPosition: function (neighbors) {\n      return bounds.getBestNewPosition(neighbors);\n    },\n\n    /**\n     * Returns bounding box which covers all bodies\n     */\n    getBBox: function () {\n      if (bboxNeedsUpdate) {\n        bounds.update();\n        bboxNeedsUpdate = false;\n      }\n\n      return bounds.box;\n    },\n    invalidateBBox: function () {\n      bboxNeedsUpdate = true;\n    },\n    gravity: function (value) {\n      if (value !== undefined) {\n        settings.gravity = value;\n        quadTree.options({\n          gravity: value\n        });\n        return this;\n      } else {\n        return settings.gravity;\n      }\n    },\n    theta: function (value) {\n      if (value !== undefined) {\n        settings.theta = value;\n        quadTree.options({\n          theta: value\n        });\n        return this;\n      } else {\n        return settings.theta;\n      }\n    }\n  }; // allow settings modification via public API:\n\n  expose(settings, publicApi);\n  eventify(publicApi);\n  return publicApi;\n\n  function accumulateForces() {\n    // Accumulate forces acting on bodies.\n    var body,\n        i = bodies.length;\n\n    if (i) {\n      // only add bodies if there the array is not empty:\n      quadTree.insertBodies(bodies); // performance: O(n * log n)\n\n      while (i--) {\n        body = bodies[i]; // If body is pinned there is no point updating its forces - it should\n        // never move:\n\n        if (!body.isPinned) {\n          body.force.reset();\n          quadTree.updateBodyForce(body);\n          dragForce.update(body);\n        }\n      }\n    }\n\n    i = springs.length;\n\n    while (i--) {\n      springForce.update(springs[i]);\n    }\n  }\n}\n\n;","map":{"version":3,"sources":["/Users/rgoren/Desktop/nextMoleAppClient/next_mole_client/node_modules/ngraph.physics.simulator/index.js"],"names":["module","exports","physicsSimulator","settings","Spring","require","expose","merge","eventify","springLength","springCoeff","gravity","theta","dragCoeff","timeStep","createQuadTree","createBounds","createDragForce","createSpringForce","integrate","integrator","createBody","bodies","springs","quadTree","bounds","springForce","dragForce","bboxNeedsUpdate","totalMovement","publicApi","step","accumulateForces","movement","update","addBody","body","Error","push","addBodyAt","pos","removeBody","idx","indexOf","splice","length","reset","addSpring","body1","body2","springCoefficient","spring","getTotalMovement","removeSpring","getBestNewBodyPosition","neighbors","getBestNewPosition","getBBox","box","invalidateBBox","value","undefined","options","i","insertBodies","isPinned","force","updateBodyForce"],"mappings":"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","sourcesContent":["/**\n * Manages a simulation of physical forces acting on bodies and springs.\n */\nmodule.exports = physicsSimulator;\n\nfunction physicsSimulator(settings) {\n  var Spring = require('./lib/spring');\n  var expose = require('ngraph.expose');\n  var merge = require('ngraph.merge');\n  var eventify = require('ngraph.events');\n\n  settings = merge(settings, {\n      /**\n       * Ideal length for links (springs in physical model).\n       */\n      springLength: 30,\n\n      /**\n       * Hook's law coefficient. 1 - solid spring.\n       */\n      springCoeff: 0.0008,\n\n      /**\n       * Coulomb's law coefficient. It's used to repel nodes thus should be negative\n       * if you make it positive nodes start attract each other :).\n       */\n      gravity: -1.2,\n\n      /**\n       * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).\n       * The closer it's to 1 the more nodes algorithm will have to go through.\n       * Setting it to one makes Barnes Hut simulation no different from\n       * brute-force forces calculation (each node is considered).\n       */\n      theta: 0.8,\n\n      /**\n       * Drag force coefficient. Used to slow down system, thus should be less than 1.\n       * The closer it is to 0 the less tight system will be.\n       */\n      dragCoeff: 0.02,\n\n      /**\n       * Default time step (dt) for forces integration\n       */\n      timeStep : 20,\n  });\n\n  // We allow clients to override basic factory methods:\n  var createQuadTree = settings.createQuadTree || require('ngraph.quadtreebh');\n  var createBounds = settings.createBounds || require('./lib/bounds');\n  var createDragForce = settings.createDragForce || require('./lib/dragForce');\n  var createSpringForce = settings.createSpringForce || require('./lib/springForce');\n  var integrate = settings.integrator || require('./lib/eulerIntegrator');\n  var createBody = settings.createBody || require('./lib/createBody');\n\n  var bodies = [], // Bodies in this simulation.\n      springs = [], // Springs in this simulation.\n      quadTree =  createQuadTree(settings),\n      bounds = createBounds(bodies, settings),\n      springForce = createSpringForce(settings),\n      dragForce = createDragForce(settings);\n\n  var bboxNeedsUpdate = true;\n  var totalMovement = 0; // how much movement we made on last step\n\n  var publicApi = {\n    /**\n     * Array of bodies, registered with current simulator\n     *\n     * Note: To add new body, use addBody() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    bodies: bodies,\n\n    quadTree: quadTree,\n\n    /**\n     * Array of springs, registered with current simulator\n     *\n     * Note: To add new spring, use addSpring() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    springs: springs,\n\n    /**\n     * Returns settings with which current simulator was initialized\n     */\n    settings: settings,\n\n    /**\n     * Performs one step of force simulation.\n     *\n     * @returns {boolean} true if system is considered stable; False otherwise.\n     */\n    step: function () {\n      accumulateForces();\n\n      var movement = integrate(bodies, settings.timeStep);\n      bounds.update();\n\n      return movement;\n    },\n\n    /**\n     * Adds body to the system\n     *\n     * @param {ngraph.physics.primitives.Body} body physical body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBody: function (body) {\n      if (!body) {\n        throw new Error('Body is required');\n      }\n      bodies.push(body);\n\n      return body;\n    },\n\n    /**\n     * Adds body to the system at given position\n     *\n     * @param {Object} pos position of a body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBodyAt: function (pos) {\n      if (!pos) {\n        throw new Error('Body position is required');\n      }\n      var body = createBody(pos);\n      bodies.push(body);\n\n      return body;\n    },\n\n    /**\n     * Removes body from the system\n     *\n     * @param {ngraph.physics.primitives.Body} body to remove\n     *\n     * @returns {Boolean} true if body found and removed. falsy otherwise;\n     */\n    removeBody: function (body) {\n      if (!body) { return; }\n\n      var idx = bodies.indexOf(body);\n      if (idx < 0) { return; }\n\n      bodies.splice(idx, 1);\n      if (bodies.length === 0) {\n        bounds.reset();\n      }\n      return true;\n    },\n\n    /**\n     * Adds a spring to this simulation.\n     *\n     * @returns {Object} - a handle for a spring. If you want to later remove\n     * spring pass it to removeSpring() method.\n     */\n    addSpring: function (body1, body2, springLength, springCoefficient) {\n      if (!body1 || !body2) {\n        throw new Error('Cannot add null spring to force simulator');\n      }\n\n      if (typeof springLength !== 'number') {\n        springLength = -1; // assume global configuration\n      }\n\n      var spring = new Spring(body1, body2, springLength, springCoefficient >= 0 ? springCoefficient : -1);\n      springs.push(spring);\n\n      // TODO: could mark simulator as dirty.\n      return spring;\n    },\n\n    /**\n     * Returns amount of movement performed on last step() call\n     */\n    getTotalMovement: function () {\n      return totalMovement;\n    },\n\n    /**\n     * Removes spring from the system\n     *\n     * @param {Object} spring to remove. Spring is an object returned by addSpring\n     *\n     * @returns {Boolean} true if spring found and removed. falsy otherwise;\n     */\n    removeSpring: function (spring) {\n      if (!spring) { return; }\n      var idx = springs.indexOf(spring);\n      if (idx > -1) {\n        springs.splice(idx, 1);\n        return true;\n      }\n    },\n\n    getBestNewBodyPosition: function (neighbors) {\n      return bounds.getBestNewPosition(neighbors);\n    },\n\n    /**\n     * Returns bounding box which covers all bodies\n     */\n    getBBox: function () {\n      if (bboxNeedsUpdate) {\n        bounds.update();\n        bboxNeedsUpdate = false;\n      }\n      return bounds.box;\n    },\n\n    invalidateBBox: function () {\n      bboxNeedsUpdate = true;\n    },\n\n    gravity: function (value) {\n      if (value !== undefined) {\n        settings.gravity = value;\n        quadTree.options({gravity: value});\n        return this;\n      } else {\n        return settings.gravity;\n      }\n    },\n\n    theta: function (value) {\n      if (value !== undefined) {\n        settings.theta = value;\n        quadTree.options({theta: value});\n        return this;\n      } else {\n        return settings.theta;\n      }\n    }\n  };\n\n  // allow settings modification via public API:\n  expose(settings, publicApi);\n\n  eventify(publicApi);\n\n  return publicApi;\n\n  function accumulateForces() {\n    // Accumulate forces acting on bodies.\n    var body,\n        i = bodies.length;\n\n    if (i) {\n      // only add bodies if there the array is not empty:\n      quadTree.insertBodies(bodies); // performance: O(n * log n)\n      while (i--) {\n        body = bodies[i];\n        // If body is pinned there is no point updating its forces - it should\n        // never move:\n        if (!body.isPinned) {\n          body.force.reset();\n\n          quadTree.updateBodyForce(body);\n          dragForce.update(body);\n        }\n      }\n    }\n\n    i = springs.length;\n    while(i--) {\n      springForce.update(springs[i]);\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}