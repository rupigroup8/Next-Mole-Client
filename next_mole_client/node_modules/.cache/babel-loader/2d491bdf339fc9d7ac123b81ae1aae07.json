{"ast":null,"code":"module.exports = function (bodies, settings) {\n  var random = require('ngraph.random').random(42);\n\n  var boundingBox = {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0\n  };\n  return {\n    box: boundingBox,\n    update: updateBoundingBox,\n    reset: function () {\n      boundingBox.x1 = boundingBox.y1 = 0;\n      boundingBox.x2 = boundingBox.y2 = 0;\n    },\n    getBestNewPosition: function (neighbors) {\n      var graphRect = boundingBox;\n      var baseX = 0,\n          baseY = 0;\n\n      if (neighbors.length) {\n        for (var i = 0; i < neighbors.length; ++i) {\n          baseX += neighbors[i].pos.x;\n          baseY += neighbors[i].pos.y;\n        }\n\n        baseX /= neighbors.length;\n        baseY /= neighbors.length;\n      } else {\n        baseX = (graphRect.x1 + graphRect.x2) / 2;\n        baseY = (graphRect.y1 + graphRect.y2) / 2;\n      }\n\n      var springLength = settings.springLength;\n      return {\n        x: baseX + random.next(springLength) - springLength / 2,\n        y: baseY + random.next(springLength) - springLength / 2\n      };\n    }\n  };\n\n  function updateBoundingBox() {\n    var i = bodies.length;\n\n    if (i === 0) {\n      return;\n    } // don't have to wory here.\n\n\n    var x1 = Number.MAX_VALUE,\n        y1 = Number.MAX_VALUE,\n        x2 = Number.MIN_VALUE,\n        y2 = Number.MIN_VALUE;\n\n    while (i--) {\n      // this is O(n), could it be done faster with quadtree?\n      // how about pinned nodes?\n      var body = bodies[i];\n\n      if (body.isPinned) {\n        body.pos.x = body.prevPos.x;\n        body.pos.y = body.prevPos.y;\n      } else {\n        body.prevPos.x = body.pos.x;\n        body.prevPos.y = body.pos.y;\n      }\n\n      if (body.pos.x < x1) {\n        x1 = body.pos.x;\n      }\n\n      if (body.pos.x > x2) {\n        x2 = body.pos.x;\n      }\n\n      if (body.pos.y < y1) {\n        y1 = body.pos.y;\n      }\n\n      if (body.pos.y > y2) {\n        y2 = body.pos.y;\n      }\n    }\n\n    boundingBox.x1 = x1;\n    boundingBox.x2 = x2;\n    boundingBox.y1 = y1;\n    boundingBox.y2 = y2;\n  }\n};","map":{"version":3,"sources":["/Users/rgoren/Desktop/nextMoleAppClient/next_mole_client/node_modules/ngraph.physics.simulator/lib/bounds.js"],"names":["module","exports","bodies","settings","random","require","boundingBox","x1","y1","x2","y2","box","update","updateBoundingBox","reset","getBestNewPosition","neighbors","graphRect","baseX","baseY","length","i","pos","x","y","springLength","next","Number","MAX_VALUE","MIN_VALUE","body","isPinned","prevPos"],"mappings":"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","sourcesContent":["module.exports = function (bodies, settings) {\n  var random = require('ngraph.random').random(42);\n  var boundingBox =  { x1: 0, y1: 0, x2: 0, y2: 0 };\n\n  return {\n    box: boundingBox,\n\n    update: updateBoundingBox,\n\n    reset : function () {\n      boundingBox.x1 = boundingBox.y1 = 0;\n      boundingBox.x2 = boundingBox.y2 = 0;\n    },\n\n    getBestNewPosition: function (neighbors) {\n      var graphRect = boundingBox;\n\n      var baseX = 0, baseY = 0;\n\n      if (neighbors.length) {\n        for (var i = 0; i < neighbors.length; ++i) {\n          baseX += neighbors[i].pos.x;\n          baseY += neighbors[i].pos.y;\n        }\n\n        baseX /= neighbors.length;\n        baseY /= neighbors.length;\n      } else {\n        baseX = (graphRect.x1 + graphRect.x2) / 2;\n        baseY = (graphRect.y1 + graphRect.y2) / 2;\n      }\n\n      var springLength = settings.springLength;\n      return {\n        x: baseX + random.next(springLength) - springLength / 2,\n        y: baseY + random.next(springLength) - springLength / 2\n      };\n    }\n  };\n\n  function updateBoundingBox() {\n    var i = bodies.length;\n    if (i === 0) { return; } // don't have to wory here.\n\n    var x1 = Number.MAX_VALUE,\n        y1 = Number.MAX_VALUE,\n        x2 = Number.MIN_VALUE,\n        y2 = Number.MIN_VALUE;\n\n    while(i--) {\n      // this is O(n), could it be done faster with quadtree?\n      // how about pinned nodes?\n      var body = bodies[i];\n      if (body.isPinned) {\n        body.pos.x = body.prevPos.x;\n        body.pos.y = body.prevPos.y;\n      } else {\n        body.prevPos.x = body.pos.x;\n        body.prevPos.y = body.pos.y;\n      }\n      if (body.pos.x < x1) {\n        x1 = body.pos.x;\n      }\n      if (body.pos.x > x2) {\n        x2 = body.pos.x;\n      }\n      if (body.pos.y < y1) {\n        y1 = body.pos.y;\n      }\n      if (body.pos.y > y2) {\n        y2 = body.pos.y;\n      }\n    }\n\n    boundingBox.x1 = x1;\n    boundingBox.x2 = x2;\n    boundingBox.y1 = y1;\n    boundingBox.y2 = y2;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}