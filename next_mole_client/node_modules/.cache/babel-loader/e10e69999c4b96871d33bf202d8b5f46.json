{"ast":null,"code":"/**\n * This is Barnes Hut simulation algorithm for 3d case. Implementation\n * is highly optimized (avoids recusion and gc pressure)\n *\n * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html\n *\n * NOTE: This module duplicates a lot of code from 2d case. Primary reason for\n * this is performance. Every time I tried to abstract away vector operations\n * I had negative impact on performance. So in this case I'm scarifying code\n * reuse in favor of speed\n */\nmodule.exports = function (options) {\n  options = options || {};\n  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n  options.theta = typeof options.theta === 'number' ? options.theta : 0.8; // we require deterministic randomness here\n\n  var random = require('ngraph.random').random(1984),\n      Node = require('./node'),\n      InsertStack = require('./insertStack'),\n      isSamePosition = require('./isSamePosition');\n\n  var gravity = options.gravity,\n      updateQueue = [],\n      insertStack = new InsertStack(),\n      theta = options.theta,\n      nodesCache = [],\n      currentInCache = 0,\n      newNode = function newNode() {\n    // To avoid pressure on GC we reuse nodes.\n    var node = nodesCache[currentInCache];\n\n    if (node) {\n      node.quad0 = null;\n      node.quad4 = null;\n      node.quad1 = null;\n      node.quad5 = null;\n      node.quad2 = null;\n      node.quad6 = null;\n      node.quad3 = null;\n      node.quad7 = null;\n      node.body = null;\n      node.mass = node.massX = node.massY = node.massZ = 0;\n      node.left = node.right = node.top = node.bottom = node.front = node.back = 0;\n    } else {\n      node = new Node();\n      nodesCache[currentInCache] = node;\n    }\n\n    ++currentInCache;\n    return node;\n  },\n      root = newNode(),\n      // Inserts body to the tree\n  insert = function insert(newBody) {\n    insertStack.reset();\n    insertStack.push(root, newBody);\n\n    while (!insertStack.isEmpty()) {\n      var stackItem = insertStack.pop(),\n          node = stackItem.node,\n          body = stackItem.body;\n\n      if (!node.body) {\n        // This is internal node. Update the total mass of the node and center-of-mass.\n        var x = body.pos.x;\n        var y = body.pos.y;\n        var z = body.pos.z;\n        node.mass += body.mass;\n        node.massX += body.mass * x;\n        node.massY += body.mass * y;\n        node.massZ += body.mass * z; // Recursively insert the body in the appropriate quadrant.\n        // But first find the appropriate quadrant.\n\n        var quadIdx = 0,\n            // Assume we are in the 0's quad.\n        left = node.left,\n            right = (node.right + left) / 2,\n            top = node.top,\n            bottom = (node.bottom + top) / 2,\n            back = node.back,\n            front = (node.front + back) / 2;\n\n        if (x > right) {\n          // somewhere in the eastern part.\n          quadIdx += 1;\n          var oldLeft = left;\n          left = right;\n          right = right + (right - oldLeft);\n        }\n\n        if (y > bottom) {\n          // and in south.\n          quadIdx += 2;\n          var oldTop = top;\n          top = bottom;\n          bottom = bottom + (bottom - oldTop);\n        }\n\n        if (z > front) {\n          // and in frontal part\n          quadIdx += 4;\n          var oldBack = back;\n          back = front;\n          front = back + (back - oldBack);\n        }\n\n        var child = getChild(node, quadIdx);\n\n        if (!child) {\n          // The node is internal but this quadrant is not taken. Add subnode to it.\n          child = newNode();\n          child.left = left;\n          child.top = top;\n          child.right = right;\n          child.bottom = bottom;\n          child.back = back;\n          child.front = front;\n          child.body = body;\n          setChild(node, quadIdx, child);\n        } else {\n          // continue searching in this quadrant.\n          insertStack.push(child, body);\n        }\n      } else {\n        // We are trying to add to the leaf node.\n        // We have to convert current leaf into internal node\n        // and continue adding two nodes.\n        var oldBody = node.body;\n        node.body = null; // internal nodes do not carry bodies\n\n        if (isSamePosition(oldBody.pos, body.pos)) {\n          // Prevent infinite subdivision by bumping one node\n          // anywhere in this quadrant\n          var retriesCount = 3;\n\n          do {\n            var offset = random.nextDouble();\n            var dx = (node.right - node.left) * offset;\n            var dy = (node.bottom - node.top) * offset;\n            var dz = (node.front - node.back) * offset;\n            oldBody.pos.x = node.left + dx;\n            oldBody.pos.y = node.top + dy;\n            oldBody.pos.z = node.back + dz;\n            retriesCount -= 1; // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n            // This is very bad, we ran out of precision.\n            // if we do not return from the method we'll get into\n            // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n            // Next layout iteration should get larger bounding box in the first step and fix this\n            return;\n          }\n        } // Next iteration should subdivide node further.\n\n\n        insertStack.push(node, oldBody);\n        insertStack.push(node, body);\n      }\n    }\n  },\n      update = function update(sourceBody) {\n    var queue = updateQueue,\n        v,\n        dx,\n        dy,\n        dz,\n        r,\n        fx = 0,\n        fy = 0,\n        fz = 0,\n        queueLength = 1,\n        shiftIdx = 0,\n        pushIdx = 1;\n    queue[0] = root;\n\n    while (queueLength) {\n      var node = queue[shiftIdx],\n          body = node.body;\n      queueLength -= 1;\n      shiftIdx += 1;\n      var differentBody = body !== sourceBody;\n\n      if (body && differentBody) {\n        // If the current node is a leaf node (and it is not source body),\n        // calculate the force exerted by the current node on body, and add this\n        // amount to body's net force.\n        dx = body.pos.x - sourceBody.pos.x;\n        dy = body.pos.y - sourceBody.pos.y;\n        dz = body.pos.z - sourceBody.pos.z;\n        r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n        if (r === 0) {\n          // Poor man's protection against zero distance.\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          dz = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        } // This is standard gravitation force calculation but we divide\n        // by r^3 to save two operations when normalizing force vector.\n\n\n        v = gravity * body.mass * sourceBody.mass / (r * r * r);\n        fx += v * dx;\n        fy += v * dy;\n        fz += v * dz;\n      } else if (differentBody) {\n        // Otherwise, calculate the ratio s / r,  where s is the width of the region\n        // represented by the internal node, and r is the distance between the body\n        // and the node's center-of-mass\n        dx = node.massX / node.mass - sourceBody.pos.x;\n        dy = node.massY / node.mass - sourceBody.pos.y;\n        dz = node.massZ / node.mass - sourceBody.pos.z;\n        r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n        if (r === 0) {\n          // Sorry about code duplication. I don't want to create many functions\n          // right away. Just want to see performance first.\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          dz = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        } // If s / r < θ, treat this internal node as a single body, and calculate the\n        // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n\n\n        if ((node.right - node.left) / r < theta) {\n          // in the if statement above we consider node's width only\n          // because the region was squarified during tree creation.\n          // Thus there is no difference between using width or height.\n          v = gravity * node.mass * sourceBody.mass / (r * r * r);\n          fx += v * dx;\n          fy += v * dy;\n          fz += v * dz;\n        } else {\n          // Otherwise, run the procedure recursively on each of the current node's children.\n          // I intentionally unfolded this loop, to save several CPU cycles.\n          if (node.quad0) {\n            queue[pushIdx] = node.quad0;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n\n          if (node.quad1) {\n            queue[pushIdx] = node.quad1;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n\n          if (node.quad2) {\n            queue[pushIdx] = node.quad2;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n\n          if (node.quad3) {\n            queue[pushIdx] = node.quad3;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n\n          if (node.quad4) {\n            queue[pushIdx] = node.quad4;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n\n          if (node.quad5) {\n            queue[pushIdx] = node.quad5;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n\n          if (node.quad6) {\n            queue[pushIdx] = node.quad6;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n\n          if (node.quad7) {\n            queue[pushIdx] = node.quad7;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n        }\n      }\n    }\n\n    sourceBody.force.x += fx;\n    sourceBody.force.y += fy;\n    sourceBody.force.z += fz;\n  },\n      insertBodies = function insertBodies(bodies) {\n    var x1 = Number.MAX_VALUE,\n        y1 = Number.MAX_VALUE,\n        z1 = Number.MAX_VALUE,\n        x2 = Number.MIN_VALUE,\n        y2 = Number.MIN_VALUE,\n        z2 = Number.MIN_VALUE,\n        i,\n        max = bodies.length; // To reduce quad tree depth we are looking for exact bounding box of all particles.\n\n    i = max;\n\n    while (i--) {\n      var pos = bodies[i].pos;\n      var x = pos.x;\n      var y = pos.y;\n      var z = pos.z;\n\n      if (x < x1) {\n        x1 = x;\n      }\n\n      if (x > x2) {\n        x2 = x;\n      }\n\n      if (y < y1) {\n        y1 = y;\n      }\n\n      if (y > y2) {\n        y2 = y;\n      }\n\n      if (z < z1) {\n        z1 = z;\n      }\n\n      if (z > z2) {\n        z2 = z;\n      }\n    } // Squarify the bounds.\n\n\n    var maxSide = Math.max(x2 - x1, Math.max(y2 - y1, z2 - z1));\n    x2 = x1 + maxSide;\n    y2 = y1 + maxSide;\n    z2 = z1 + maxSide;\n    currentInCache = 0;\n    root = newNode();\n    root.left = x1;\n    root.right = x2;\n    root.top = y1;\n    root.bottom = y2;\n    root.back = z1;\n    root.front = z2;\n    i = max - 1;\n\n    if (i > 0) {\n      root.body = bodies[i];\n    }\n\n    while (i--) {\n      insert(bodies[i], root);\n    }\n  };\n\n  return {\n    insertBodies: insertBodies,\n    updateBodyForce: update,\n    options: function options(newOptions) {\n      if (newOptions) {\n        if (typeof newOptions.gravity === 'number') {\n          gravity = newOptions.gravity;\n        }\n\n        if (typeof newOptions.theta === 'number') {\n          theta = newOptions.theta;\n        }\n\n        return this;\n      }\n\n      return {\n        gravity: gravity,\n        theta: theta\n      };\n    }\n  };\n};\n\nfunction getChild(node, idx) {\n  if (idx === 0) return node.quad0;\n  if (idx === 1) return node.quad1;\n  if (idx === 2) return node.quad2;\n  if (idx === 3) return node.quad3;\n  if (idx === 4) return node.quad4;\n  if (idx === 5) return node.quad5;\n  if (idx === 6) return node.quad6;\n  if (idx === 7) return node.quad7;\n  return null;\n}\n\nfunction setChild(node, idx, child) {\n  if (idx === 0) node.quad0 = child;else if (idx === 1) node.quad1 = child;else if (idx === 2) node.quad2 = child;else if (idx === 3) node.quad3 = child;else if (idx === 4) node.quad4 = child;else if (idx === 5) node.quad5 = child;else if (idx === 6) node.quad6 = child;else if (idx === 7) node.quad7 = child;\n}","map":{"version":3,"sources":["/Users/rgoren/Desktop/nextMoleAppClient/next_mole_client/node_modules/ngraph.quadtreebh3d/index.js"],"names":["module","exports","options","gravity","theta","random","require","Node","InsertStack","isSamePosition","updateQueue","insertStack","nodesCache","currentInCache","newNode","node","quad0","quad4","quad1","quad5","quad2","quad6","quad3","quad7","body","mass","massX","massY","massZ","left","right","top","bottom","front","back","root","insert","newBody","reset","push","isEmpty","stackItem","pop","x","pos","y","z","quadIdx","oldLeft","oldTop","oldBack","child","getChild","setChild","oldBody","retriesCount","offset","nextDouble","dx","dy","dz","update","sourceBody","queue","v","r","fx","fy","fz","queueLength","shiftIdx","pushIdx","differentBody","Math","sqrt","force","insertBodies","bodies","x1","Number","MAX_VALUE","y1","z1","x2","MIN_VALUE","y2","z2","i","max","length","maxSide","updateBodyForce","newOptions","idx"],"mappings":"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","sourcesContent":["/**\n * This is Barnes Hut simulation algorithm for 3d case. Implementation\n * is highly optimized (avoids recusion and gc pressure)\n *\n * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html\n *\n * NOTE: This module duplicates a lot of code from 2d case. Primary reason for\n * this is performance. Every time I tried to abstract away vector operations\n * I had negative impact on performance. So in this case I'm scarifying code\n * reuse in favor of speed\n */\n\nmodule.exports = function(options) {\n  options = options || {};\n  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;\n\n  // we require deterministic randomness here\n  var random = require('ngraph.random').random(1984),\n    Node = require('./node'),\n    InsertStack = require('./insertStack'),\n    isSamePosition = require('./isSamePosition');\n\n  var gravity = options.gravity,\n    updateQueue = [],\n    insertStack = new InsertStack(),\n    theta = options.theta,\n\n    nodesCache = [],\n    currentInCache = 0,\n    newNode = function() {\n      // To avoid pressure on GC we reuse nodes.\n      var node = nodesCache[currentInCache];\n      if (node) {\n        node.quad0 = null;\n        node.quad4 = null;\n        node.quad1 = null;\n        node.quad5 = null;\n        node.quad2 = null;\n        node.quad6 = null;\n        node.quad3 = null;\n        node.quad7 = null;\n        node.body = null;\n        node.mass = node.massX = node.massY = node.massZ = 0;\n        node.left = node.right = node.top = node.bottom = node.front = node.back = 0;\n      } else {\n        node = new Node();\n        nodesCache[currentInCache] = node;\n      }\n\n      ++currentInCache;\n      return node;\n    },\n\n    root = newNode(),\n\n    // Inserts body to the tree\n    insert = function(newBody) {\n      insertStack.reset();\n      insertStack.push(root, newBody);\n\n      while (!insertStack.isEmpty()) {\n        var stackItem = insertStack.pop(),\n          node = stackItem.node,\n          body = stackItem.body;\n\n        if (!node.body) {\n          // This is internal node. Update the total mass of the node and center-of-mass.\n          var x = body.pos.x;\n          var y = body.pos.y;\n          var z = body.pos.z;\n          node.mass += body.mass;\n          node.massX += body.mass * x;\n          node.massY += body.mass * y;\n          node.massZ += body.mass * z;\n\n          // Recursively insert the body in the appropriate quadrant.\n          // But first find the appropriate quadrant.\n          var quadIdx = 0, // Assume we are in the 0's quad.\n            left = node.left,\n            right = (node.right + left) / 2,\n            top = node.top,\n            bottom = (node.bottom + top) / 2,\n            back = node.back,\n            front = (node.front + back) / 2;\n\n          if (x > right) { // somewhere in the eastern part.\n            quadIdx += 1;\n            var oldLeft = left;\n            left = right;\n            right = right + (right - oldLeft);\n          }\n          if (y > bottom) { // and in south.\n            quadIdx += 2;\n            var oldTop = top;\n            top = bottom;\n            bottom = bottom + (bottom - oldTop);\n          }\n          if (z > front) { // and in frontal part\n            quadIdx += 4;\n            var oldBack = back;\n            back = front;\n            front = back + (back - oldBack);\n          }\n\n          var child = getChild(node, quadIdx);\n          if (!child) {\n            // The node is internal but this quadrant is not taken. Add subnode to it.\n            child = newNode();\n            child.left = left;\n            child.top = top;\n            child.right = right;\n            child.bottom = bottom;\n            child.back = back;\n            child.front = front;\n            child.body = body;\n\n            setChild(node, quadIdx, child);\n          } else {\n            // continue searching in this quadrant.\n            insertStack.push(child, body);\n          }\n        } else {\n          // We are trying to add to the leaf node.\n          // We have to convert current leaf into internal node\n          // and continue adding two nodes.\n          var oldBody = node.body;\n          node.body = null; // internal nodes do not carry bodies\n\n          if (isSamePosition(oldBody.pos, body.pos)) {\n            // Prevent infinite subdivision by bumping one node\n            // anywhere in this quadrant\n            var retriesCount = 3;\n            do {\n              var offset = random.nextDouble();\n              var dx = (node.right - node.left) * offset;\n              var dy = (node.bottom - node.top) * offset;\n              var dz = (node.front - node.back) * offset;\n\n              oldBody.pos.x = node.left + dx;\n              oldBody.pos.y = node.top + dy;\n              oldBody.pos.z = node.back + dz;\n              retriesCount -= 1;\n              // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n            } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n            if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n              // This is very bad, we ran out of precision.\n              // if we do not return from the method we'll get into\n              // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n              // Next layout iteration should get larger bounding box in the first step and fix this\n              return;\n            }\n          }\n          // Next iteration should subdivide node further.\n          insertStack.push(node, oldBody);\n          insertStack.push(node, body);\n        }\n      }\n    },\n\n    update = function(sourceBody) {\n      var queue = updateQueue,\n        v,\n        dx, dy, dz,\n        r, fx = 0,\n        fy = 0,\n        fz = 0,\n        queueLength = 1,\n        shiftIdx = 0,\n        pushIdx = 1;\n\n      queue[0] = root;\n\n      while (queueLength) {\n        var node = queue[shiftIdx],\n          body = node.body;\n\n        queueLength -= 1;\n        shiftIdx += 1;\n        var differentBody = (body !== sourceBody);\n        if (body && differentBody) {\n          // If the current node is a leaf node (and it is not source body),\n          // calculate the force exerted by the current node on body, and add this\n          // amount to body's net force.\n          dx = body.pos.x - sourceBody.pos.x;\n          dy = body.pos.y - sourceBody.pos.y;\n          dz = body.pos.z - sourceBody.pos.z;\n          r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n          if (r === 0) {\n            // Poor man's protection against zero distance.\n            dx = (random.nextDouble() - 0.5) / 50;\n            dy = (random.nextDouble() - 0.5) / 50;\n            dz = (random.nextDouble() - 0.5) / 50;\n            r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n          }\n\n          // This is standard gravitation force calculation but we divide\n          // by r^3 to save two operations when normalizing force vector.\n          v = gravity * body.mass * sourceBody.mass / (r * r * r);\n          fx += v * dx;\n          fy += v * dy;\n          fz += v * dz;\n        } else if (differentBody) {\n          // Otherwise, calculate the ratio s / r,  where s is the width of the region\n          // represented by the internal node, and r is the distance between the body\n          // and the node's center-of-mass\n          dx = node.massX / node.mass - sourceBody.pos.x;\n          dy = node.massY / node.mass - sourceBody.pos.y;\n          dz = node.massZ / node.mass - sourceBody.pos.z;\n\n          r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n          if (r === 0) {\n            // Sorry about code duplication. I don't want to create many functions\n            // right away. Just want to see performance first.\n            dx = (random.nextDouble() - 0.5) / 50;\n            dy = (random.nextDouble() - 0.5) / 50;\n            dz = (random.nextDouble() - 0.5) / 50;\n            r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n          }\n\n          // If s / r < θ, treat this internal node as a single body, and calculate the\n          // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n          if ((node.right - node.left) / r < theta) {\n            // in the if statement above we consider node's width only\n            // because the region was squarified during tree creation.\n            // Thus there is no difference between using width or height.\n            v = gravity * node.mass * sourceBody.mass / (r * r * r);\n            fx += v * dx;\n            fy += v * dy;\n            fz += v * dz;\n          } else {\n            // Otherwise, run the procedure recursively on each of the current node's children.\n\n            // I intentionally unfolded this loop, to save several CPU cycles.\n            if (node.quad0) {\n              queue[pushIdx] = node.quad0;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad1) {\n              queue[pushIdx] = node.quad1;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad2) {\n              queue[pushIdx] = node.quad2;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad3) {\n              queue[pushIdx] = node.quad3;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad4) {\n              queue[pushIdx] = node.quad4;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad5) {\n              queue[pushIdx] = node.quad5;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad6) {\n              queue[pushIdx] = node.quad6;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad7) {\n              queue[pushIdx] = node.quad7;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n          }\n        }\n      }\n\n      sourceBody.force.x += fx;\n      sourceBody.force.y += fy;\n      sourceBody.force.z += fz;\n    },\n\n    insertBodies = function(bodies) {\n      var x1 = Number.MAX_VALUE,\n        y1 = Number.MAX_VALUE,\n        z1 = Number.MAX_VALUE,\n        x2 = Number.MIN_VALUE,\n        y2 = Number.MIN_VALUE,\n        z2 = Number.MIN_VALUE,\n        i,\n        max = bodies.length;\n\n      // To reduce quad tree depth we are looking for exact bounding box of all particles.\n      i = max;\n      while (i--) {\n        var pos = bodies[i].pos;\n        var x = pos.x;\n        var y = pos.y;\n        var z = pos.z;\n        if (x < x1) {\n          x1 = x;\n        }\n        if (x > x2) {\n          x2 = x;\n        }\n        if (y < y1) {\n          y1 = y;\n        }\n        if (y > y2) {\n          y2 = y;\n        }\n        if (z < z1) {\n          z1 = z;\n        }\n        if (z > z2) {\n          z2 = z;\n        }\n      }\n\n      // Squarify the bounds.\n      var maxSide = Math.max(x2 - x1, Math.max(y2 - y1, z2 - z1));\n\n      x2 = x1 + maxSide;\n      y2 = y1 + maxSide;\n      z2 = z1 + maxSide;\n\n      currentInCache = 0;\n      root = newNode();\n      root.left = x1;\n      root.right = x2;\n      root.top = y1;\n      root.bottom = y2;\n      root.back = z1;\n      root.front = z2;\n\n      i = max - 1;\n      if (i > 0) {\n        root.body = bodies[i];\n      }\n      while (i--) {\n        insert(bodies[i], root);\n      }\n    };\n\n  return {\n    insertBodies: insertBodies,\n    updateBodyForce: update,\n    options: function(newOptions) {\n      if (newOptions) {\n        if (typeof newOptions.gravity === 'number') {\n          gravity = newOptions.gravity;\n        }\n        if (typeof newOptions.theta === 'number') {\n          theta = newOptions.theta;\n        }\n\n        return this;\n      }\n\n      return {\n        gravity: gravity,\n        theta: theta\n      };\n    }\n  };\n};\n\nfunction getChild(node, idx) {\n  if (idx === 0) return node.quad0;\n  if (idx === 1) return node.quad1;\n  if (idx === 2) return node.quad2;\n  if (idx === 3) return node.quad3;\n  if (idx === 4) return node.quad4;\n  if (idx === 5) return node.quad5;\n  if (idx === 6) return node.quad6;\n  if (idx === 7) return node.quad7;\n  return null;\n}\n\nfunction setChild(node, idx, child) {\n  if (idx === 0) node.quad0 = child;\n  else if (idx === 1) node.quad1 = child;\n  else if (idx === 2) node.quad2 = child;\n  else if (idx === 3) node.quad3 = child;\n  else if (idx === 4) node.quad4 = child;\n  else if (idx === 5) node.quad5 = child;\n  else if (idx === 6) node.quad6 = child;\n  else if (idx === 7) node.quad7 = child;\n}\n"]},"metadata":{},"sourceType":"script"}